package pilas;

/**
 *
 * @Felipe
 */
public class pilas {
    
    int limite, tope, vec[];

    public pilas(int n) {
        this.limite = n-1;
        this.tope = -1;
        this.vec = new int[n];
    }

    public int getLimite() {
        return limite;
    }

    public void setLimite(int limite) {
        this.limite = limite;
    }

    public int getTope() {
        return tope;
    }

    public void setTope(int tope) {
        this.tope = tope;
    }

    public int[] getVec() {
        return vec;
    }

    public void setVec(int[] vec) {
        this.vec = vec;
    }
    
    //MÃ©todos
    
    public boolean PilaVacia(){
        
        if(tope == -1)
            return true;
        else
            return false;
        
    }
    
    public boolean PilaLlena(){
        
        boolean b = false;
        if (tope==limite)
            b=true;
        return b;
        
    }
    
    public void Apilar(int d){
        
        tope++;
        vec[tope] = d;
    }
    
    public int Desapilar(){
        
        int Aux = vec[tope];
        tope--;
        return Aux;
    }
    
    public void pasardato(pilas pa){
        
        while(!pa.PilaVacia()){
            Apilar(d:pa.Desapilar());
        }
    }
    
    public void Mostrar (){
        
        pilas pa = new pilas (limite+1);
        int aux = 0;
        string s = "";
        
        while (!this.pilaVacia()){
            aux=this.Desapilar();
            s = s + "|" + aux + "\n ___ \n" + "|";
        }
    }

    public void OrdenarAsc()
    {
        Pila pa = new Pila(n);
        Pila pa2 = new Pila(n);
        int aux = 0;
        
        PA.LlenarPila(this);
        aux = PA.Desapilar();
        
        while (!PA.PilaVacia())
        {
            if (aux > PA.Vp[PA.tope])
            {
                PA2.Apilar(aux);
                aux = PA.Desapilar();   
            }
            else
            {
                PA2.Apilar(PA.Desapilar());                
            }
        
        }
        
        this.Apilar(aux);
        PA.LlenarPila(pa2);
        aux = PA.Desapilar();

        
       
    }
    
}

//apilar,desapilar,apilar ordenado, apilar ascendente y descendente, buscar, eliminar